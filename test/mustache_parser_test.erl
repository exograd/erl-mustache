%% Copyright (c) 2020-2021 Exograd SAS.
%%
%% Permission to use, copy, modify, and/or distribute this software for any
%% purpose with or without fee is hereby granted, provided that the above
%% copyright notice and this permission notice appear in all copies.
%%
%% THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
%% WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
%% MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
%% SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
%% WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
%% ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
%% IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

-module(mustache_parser_test).

-include_lib("eunit/include/eunit.hrl").

parse_test_() ->
  Parse = fun mustache_parser:parse/1,
  [?_assertMatch({ok, []},
                 Parse(<<"">>)),
   ?_assertMatch({ok, [#{type := text, value := <<"foo">>}]},
                 Parse(<<"foo">>)),
   ?_assertMatch({ok, [#{type := text, value := <<"foo\nbar\n\nbaz\n">>}]},
                 Parse(<<"foo\nbar\n\nbaz\n">>)),
   ?_assertMatch({ok, [#{type := variable, value := <<"label">>},
                       #{type := text, value := <<": a=">>},
                       #{type := variable, value := <<"n">>},
                       #{type := text, value := <<"\n">>},
                       #{type := variable, value := <<"footer">>},
                       #{type := text, value := <<"\n">>}]},
                 Parse(<<"{{label}}: a={{n}}\n{{footer}}\n">>)),
   ?_assertMatch({ok, [#{type := text, value := <<"data: ">>},
                       #{type := unescaped_variable, value := <<"data">>},
                       #{type := text, value := <<" (">>},
                       #{type := unescaped_variable, value := <<"data2">>},
                       #{type := text, value := <<", ">>},
                       #{type := unescaped_variable, value := <<"data3">>},
                       #{type := text, value := <<")">>}]},
                 Parse(<<"data: {{{data}}} ({{&data2}}, {{&  data3  }})">>)),
   ?_assertMatch({ok, [#{type := unescaped_variable, value := <<"foo">>},
                       #{type := unescaped_variable, value := <<"bar">>}]},
                 Parse(<<"{{{foo}}}{{{ bar\t}}}">>)),
   ?_assertMatch({ok, [#{type := section, value := <<"s">>, children := []}]},
                 Parse(<<"{{#s}}{{/s}}">>)),
   ?_assertMatch({ok, [#{type := section, value :=<<"foo">>,
                         children :=[#{type := text, value := <<"a ">>},
                                     #{type := variable, value := <<"b">>},
                                     #{type := text, value := <<" c">>}]}]},
                 Parse(<<"{{# foo}}a {{b}} c{{/ foo }}">>)),
   ?_assertMatch({ok, [#{type := section, value := <<"a">>,
                         children := [#{type := section, value := <<"a">>,
                                        children := [#{type := variable,
                                                       value := <<"a">>}]}]}]},
                 Parse(<<"{{#a}}{{#a}}{{a}}{{/a}}{{/a}}">>)),
   ?_assertMatch({ok, [#{type := section, value := <<"a">>,
                         children := [#{type := inverted_section,
                                        value := <<"b">>,
                                        children := [#{type := text,
                                                       value := <<"xy">>}]}]}]},
                 Parse(<<"{{# a}}{{^b}}xy{{/b}}{{/ a }}">>)),
   ?_assertMatch({ok, [#{type := text, value := <<"foo">>},
                       #{type := comment, value := <<"hello world!">>},
                       #{type := text, value := <<"bar">>},
                       #{type := comment, value := <<"foo\n{bar}\nbaz">>}]},
                 Parse(<<"foo{{! hello world!}}bar{{! foo\n{bar}\nbaz  }}">>)),
   ?_assertMatch({ok, [#{type := partial, value := <<"header">>},
                       #{type := text, value := <<" ">>},
                       #{type := partial, value := <<"foo ter">>}]},
                 Parse(<<"{{> header}} {{>foo ter }}">>)),
   ?_assertMatch({ok, [#{type := text, value := <<"{{a}}">>},
                       #{type := variable, value := <<"b">>},
                       #{type := text, value := <<"\n">>},
                       #{type := variable, value := <<"a">>},
                       #{type := text, value := <<"<%b%>">>}]},
                 Parse(<<"{{=<% %>=}}\n{{a}}<%b%>\n<%={{ }}=%>{{a}}<%b%>">>)),
   ?_assertMatch({ok, [#{type := text, value := <<"{{a}}">>},
                       #{type := variable, value := <<"b">>},
                       #{type := text, value := <<"\n">>},
                       #{type := variable, value := <<"a">>},
                       #{type := text, value := <<"@@b@@">>}]},
                 Parse(<<"{{=@@ @@=}}\n{{a}}@@b@@\n@@={{ }}=@@{{a}}@@b@@">>)),
   ?_assertEqual({error, #{position => {1, 1},
                           reason => truncated_tag}},
                 Parse(<<"{{a}">>)),
   ?_assertEqual({error, #{position => {1, 1},
                           reason => truncated_tag}},
                 Parse(<<"{{a}\n{{foo}}">>)),
   ?_assertEqual({error, #{position => {1, 1},
                           reason => truncated_tag}},
                 Parse(<<"{{a}\r\n{{foo}}">>)),
   ?_assertEqual({error, #{position => {1, 1},
                           reason => truncated_tag}},
                 Parse(<<"{{">>)),
   ?_assertEqual({error, #{position => {1, 7},
                           reason => truncated_tag}},
                 Parse(<<"{{#a}}{{/">>)),
   ?_assertEqual({error, #{position => {1, 1},
                           reason => empty_tag}},
                 Parse(<<"{{}}">>)),
   ?_assertEqual({error, #{position => {1, 7},
                           reason => empty_tag}},
                 Parse(<<"{{#a}}{{/}}">>)),
   ?_assertEqual({error, #{position => {1, 1},
                           reason => {truncated_section, <<"a">>}}},
                 Parse(<<"{{#a}}">>)),
   ?_assertEqual({error, #{position => {1, 1},
                           reason => {truncated_section, <<"a">>}}},
                 Parse(<<"{{#a}}">>)),
   ?_assertEqual({error, #{position => {1, 13},
                           reason => {section_name_mismatch, <<"b">>, <<"a">>}}},
                 Parse(<<"{{#a}}{{#a}}{{/b}}{{/a}}">>))].
